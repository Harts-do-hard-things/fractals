# -*- coding: utf-8 -*-
"""
Created on Sun Jan  5 15:15:59 2025

@author: emmet
"""


import numpy as np
from PIL import Image
from matplotlib import colors
import matplotlib.pyplot as plt
import cmath

I = np.array([[1, 0, 0],
              [0, 1, 0]])
COLORS = [(np.array(
    colors.to_rgb(colors.TABLEAU_COLORS[i])) * 255 // 1).astype("uint8")
    for i in ['tab:blue', 'tab:orange', 'tab:green', 'tab:red', 'tab:purple']
    ]



class ArrayFractal:
    """A class used to draw and calculate Fractals.

    Fractals can be generated by using one of the premade classes, or by
    creating a new fractal with arbitrary starting points and functions.
    Note: The majority of funtion systems don't result in fractals.

    Once created, fractals are iterated using (index.md#Fractal.iterate)

    Based on research by
    [Larry Riddle](https://larryriddle.agnesscott.org/ifs/ifs.htm)

    Attributes
    ----------
    S : np.array

        Default S0 = (0 + 0j) to (1 + 0j)
        the current points of the fractal

    func_list : list[functions]

        the functions to be applied every iteration


    Methods
    -------
    iterate(i: int)
        Applies func_list to the current points, S, and updates S to match

    plot()
        Plots the points S using matplotlib

    save_gif(iterations: int, duration: int = 1000)
    saves a gif at '__name__ _iterations.gif' with a frame duration of duration
    milliseconds

    """

    def __init__(self, S0: np.array, eq: np.array):
        """
        Parameters
        ----------
        S0 : list[complex]
            The initial points to iterate
        func_list : list[Callable]
            A list of funtions that determines the function system

        Returns
        -------
        Fractal

        """
        self._S0 = S0
        self.S = S0
        self.trans_list, self.prob_list = self.create_functions(eq)
        self.trans_used = []
        self._plot_list = [S0]
        self.limits = self.calculate_limits()

    @staticmethod
    def apply(data: np.ndarray, trans_matrix: np.ndarray):
        ndata = np.add(data.dot(trans_matrix[:2, :2].T), trans_matrix[:, 2])
        return ndata

    @staticmethod
    def from_imaginary(S0: list[complex], func_list: list[callable]):
        S = np.stack((np.real(S0), np.imag(S0)), axis=1) 
        eq = np.zeros((len(func_list), 6))
        for i, func in enumerate(func_list):
            trans = np.array(([np.real(func(0))], [np.imag(func(0))]))
            rotation = func(1) - func(0)
            matrix = np.array([[np.real(rotation), -np.imag(rotation)],
                               [np.imag(rotation), np.real(rotation)]])
            e = np.append(matrix, trans)
            eq[i] = e
            # print(S, e)
        return ArrayFractal(S, eq)

    def create_functions(self, eq, run_prob=False):
        if len(eq[0]) % 2 == 1:
            i = (len(eq[0]) - 1) // 3
            trans_list = [np.append(e[: 2 * i].reshape((2, -1)), e[-1 - i: -1]
                      .reshape(-1, 1), 1)
            for e in np.array(eq)]
        else:
            i = len(eq[0]) // 3
            run_prob = True
        trans_list = [
            np.append(e[: 2 * i].reshape((2, -1)), e[-i:]
                      .reshape(-1, 1), 1)
            for e in np.array(eq)
        ]
        prob_list = self.calculate_probabilities(trans_list) \
                    if run_prob else eq[:, -1]
        return trans_list, prob_list

    @staticmethod
    def calculate_probabilities(trans_list):
        det_list = [abs(np.linalg.det(a[:2, :2]))
                    if abs(np.linalg.det(a[:2, :2])) != 0 else .003
                    for a in trans_list]
        normalize = [a / sum(det_list) for a in det_list]
        return normalize

    def calculate_limits(self):
        self.random_iterate(10_000)
        mins = np.min(self.S, axis=0)
        maxs = np.max(self.S, axis=0)
        expected_diff = max(maxs - mins) * 1.05
        diff = maxs - mins

        maxmin = np.array(
            (mins - (expected_diff - diff) / 2,
             maxs + (expected_diff - diff) / 2))
        self.reset()
        return maxmin.flatten('F')

    def get_xlim(self):
        return self.limits[:2]
    
    def get_ylim(self):
        return self.limits[2:]
    
    xlim = property(get_xlim)
    ylim = property(get_ylim)

    def reset(self):
        """
        Resets the fractal to initial conditions.

        Returns
        -------
        None.

        """
        self.S = self._S0.copy()
        self._plot_list = [self._S0]

    def segment(self, points: np.array) -> np.array:
        len_ = len(self._S0)
        lines = np.full((len(points) // len_, len_ * 2 + 2), np.nan)
        lines[:,:len_*2] = points.reshape((-1, 4))
        return lines.reshape((-1, 2))

    def deterministic_iterate(self, i: int=1) -> None:
        """maps the functions to S, reassigning S

        if used with the gif package
        clears the plot list (ensures proper gif plotting)
        appends S back to plot list

        Parameters
        ----------
        i : int
            The number of iterations to advance from the current state

        Returns
        -------
        None

        """
        self._plot_list.clear()
        S = np.zeros((len(self.S)*len(self.trans_list)**i, 2))
        for _ in range(i):
            for j, trans in enumerate(self.trans_list):
                len_ = len(self.S)
                S[j * len_:(j + 1) * len_] = self.apply(self.S, trans)
            self.S = S[:(j + 1) * len_].copy()
        self._plot_list.append(self.segment(S))

    def random_apply(self, point):
        index = np.random.choice(len(self.prob_list), p=self.prob_list)
        final_point = self.apply(point, self.trans_list[index])
        return final_point, index
    
    def random_iterate(self, n):
        point = np.array([0, 0])
        for _ in range(1_000):
            point, _ = self.random_apply(point)

        self.S = np.empty((n, 2))

        for i in range(n):
            point, index = self.random_apply(point)
            self.S[i] = point
            self.trans_used.append(index)        

    def divided_iterate(self, i:int=1):
        """maps the functions to S, reassigning S,
        but dividing the resulting plot list by the # of functions
        to plot each one with a different color

        if used with the gif package
        clears the plot list (ensures proper gif plotting)
        appends the result of each transformation to plot list

        Parameters
        ----------
        i : int
            The number of iterations to advance from the current state

        Returns
        -------
        None

        """
        self._plot_list.clear()
        if i == 1:
            len_ = len(self.S)
            S = np.zeros((len_ * len(self.trans_list), 2))
            for i, trans in enumerate(self.trans_list):
                S[i * len_:(i + 1) * len_] = self.apply(self.S, trans)
                self._plot_list.append(S[i * len_:(i + 1) * len_])
            self.S = S.copy()
        else:
            self.deterministic_iterate(i - 1)
            self.divided_iterate(1)
            
    def translate(self, rotate: np.array, offset: np.array) -> None:
        """Translate and rotate the fractal using a matrix adding the
        translated version to the plot list

        Parameters
        ----------
        offset : complex
            The vector to use as offset
        angle : float
            The angle (in radians) to rotate

        Returns
        -------
        None

        """
        s_trans = self.apply(
            self._plot_list[0], np.append(rotate, offset, axis=1))
        self._plot_list.append(s_trans)

    def tile(self):
        pass

    def translate_in_place(self, rotate: np.array, offset: np.array) -> None:
        """
        Translates every element in _plot_list

        Parameters
        ----------
        offset : complex
            DESCRIPTION.
        angle : float
            DESCRIPTION.

        Returns
        -------
        None
            DESCRIPTION.

        """
        self._plot_list = [ self.apply(
            i, np.append(rotate, offset, axis=1)) for i in self._plot_list]

    def scale(self, scale: float) -> None:
        self._plot_list = [self.apply(i, scale*I) for i in self._plot_list]

    def make_image(self, resolution=(1080, 1080)):
        pixels = np.uint8(
            [[(0, 0, 0, 0) for _ in range(resolution[0])] 
             for _ in range(resolution[1])]
            )
        # for point, index in zip(self.S, self.trans_used):
        for point in self.S:
            x, y = point
            res = min(resolution)
            pixelx = int((x - self.xlim[0])/(self.xlim[1] - self.xlim[0]) * res)
            pixely = int((self.ylim[1] - y)/(self.ylim[1] - self.ylim[0]) * res)
            # pixels[pixely, pixelx] = np.append(COLORS[index], 255)
            pixels[pixely, pixelx] = np.append(COLORS[0], 255)
        return Image.fromarray(pixels, "RGBA")
    
    def plot(self, autoscale=False):
        """Plots the fractal for human viewing"""
        self.tile()
        fig = plt.figure()
        self._fig = fig
        ax = fig.add_subplot(111)
        self._ax = ax
        self.plot_handle = [
            # ax.plot(np.real(s), np.imag(s), color="tab:blue") for s in self._plot_list
            ax.plot(s[:,0], s[:,1]) for s in self._plot_list
        ]
        if not autoscale:
            ax.set_xlim(self.limits[:2])
            ax.set_ylim(self.limits[2:])
        ax.set_aspect("equal")
        ax.axis("off")
        plt.show()

    def get_plot_fig(self):
        return self._fig
    
    def get_plot_ax(self):
        return self._ax
    
    plot_fig = property(get_plot_fig)
    plot_ax = property(get_plot_ax)


if __name__ == "__main__":
#     levy_c = ArrayFractal(np.array([[0.0, 0.],
#                                    [1., 0.]]), 
#                np.array([[.5, -.5, .5, .5, 0, 0, .5],
#                         [-.5, -.5, .5, -.5, 1, 0, .5]])
# )
#     # levy_c.plot()
    from fractal import S0i, IFS_function
    test = ArrayFractal.from_imaginary(S0i, IFS_function["flowsnake"])
    test.divided_iterate(7)
    test.plot()